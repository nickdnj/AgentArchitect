#!/usr/bin/env node

/**
 * Agent Generation Script
 *
 * Generates Claude Code native agent files from Agent Architect definitions.
 * Source: agents/<agent-id>/SKILL.md + config.json
 * Output: .claude/agents/<agent-id>.md
 *
 * Usage: node scripts/generate-agents.js [--agent <agent-id>]
 */

const fs = require('fs');
const path = require('path');

// Configuration
const AGENTS_DIR = path.join(__dirname, '..', 'agents');
const OUTPUT_DIR = path.join(__dirname, '..', '.claude', 'agents');

// MCP Server mapping: Agent Architect config -> Claude Code tools
const MCP_SERVER_MAPPING = {
  'gdrive': 'mcp__google-drive__*',
  'gdrive-personal': 'mcp__google-drive__*',
  'gmail': 'mcp__gmail__*',
  'gmail-personal': 'mcp__gmail-personal__*',
  'google-docs': 'mcp__google-docs-mcp__*',
  'chrome': 'mcp__chrome__*',
  'github': 'Bash',  // GitHub CLI via bash
  'firebase': 'Bash',  // Firebase CLI via bash
  'google-cloud': 'Bash',  // gcloud CLI via bash
  'powerpoint': 'mcp__powerpoint__*',
  'voicemode': 'mcp__voicemode__*',
};

// Base tools that all agents should have access to
const BASE_TOOLS = [
  'Read',
  'Write',
  'Edit',
  'Glob',
  'Grep',
  'Bash',
  'Task',
  'WebFetch',
  'WebSearch',
];

/**
 * Read and parse an agent's config.json
 */
function readAgentConfig(agentDir) {
  const configPath = path.join(agentDir, 'config.json');
  if (!fs.existsSync(configPath)) {
    return null;
  }
  const content = fs.readFileSync(configPath, 'utf-8');
  return JSON.parse(content);
}

/**
 * Read an agent's SKILL.md content
 */
function readAgentSkill(agentDir) {
  const skillPath = path.join(agentDir, 'SKILL.md');
  if (!fs.existsSync(skillPath)) {
    return null;
  }
  return fs.readFileSync(skillPath, 'utf-8');
}

/**
 * Map MCP servers from config to Claude Code tool patterns
 */
function mapMcpServersToTools(mcpServers) {
  const tools = new Set(BASE_TOOLS);

  if (!mcpServers || !Array.isArray(mcpServers)) {
    return Array.from(tools);
  }

  for (const server of mcpServers) {
    const mappedTool = MCP_SERVER_MAPPING[server];
    if (mappedTool) {
      tools.add(mappedTool);
    }
  }

  return Array.from(tools);
}

/**
 * Generate YAML frontmatter for the agent
 */
function generateFrontmatter(config, tools) {
  const lines = ['---'];
  lines.push(`name: ${config.name}`);
  lines.push(`description: ${config.description}`);
  lines.push('tools:');
  for (const tool of tools) {
    lines.push(`  - ${tool}`);
  }
  lines.push('---');
  return lines.join('\n');
}

/**
 * Generate metadata comments to preserve Agent Architect data
 */
function generateMetadataComments(config) {
  const lines = [
    '',
    '<!-- GENERATED BY AGENT ARCHITECT - DO NOT EDIT DIRECTLY -->',
    `<!-- Source: agents/${config.id}/ -->`,
    '<!-- To modify: Edit SKILL.md and config.json, then run /sync-agents -->',
  ];

  // Preserve collaboration data
  if (config.collaboration) {
    lines.push(`<!-- collaboration: ${JSON.stringify(config.collaboration)} -->`);
  }

  // Preserve workflow position data
  if (config.workflow_position) {
    lines.push(`<!-- workflow: ${JSON.stringify(config.workflow_position)} -->`);
  }

  // Preserve expertise data
  if (config.expertise) {
    lines.push(`<!-- expertise: ${JSON.stringify(config.expertise)} -->`);
  }

  // Preserve context bucket assignments
  if (config.context_buckets) {
    lines.push(`<!-- context_buckets: ${JSON.stringify(config.context_buckets)} -->`);
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Generate a complete Claude Code agent file
 */
function generateAgentFile(config, skillContent) {
  const tools = mapMcpServersToTools(config.mcp_servers);
  const frontmatter = generateFrontmatter(config, tools);
  const metadata = generateMetadataComments(config);

  return `${frontmatter}${metadata}${skillContent}`;
}

/**
 * Process a single agent
 */
function processAgent(agentId) {
  const agentDir = path.join(AGENTS_DIR, agentId);

  // Skip template directories
  if (agentId.startsWith('_')) {
    return { skipped: true, reason: 'template directory' };
  }

  // Check if directory exists
  if (!fs.existsSync(agentDir) || !fs.statSync(agentDir).isDirectory()) {
    return { error: `Agent directory not found: ${agentDir}` };
  }

  // Read config
  const config = readAgentConfig(agentDir);
  if (!config) {
    return { error: `config.json not found for agent: ${agentId}` };
  }

  // Read SKILL.md
  const skillContent = readAgentSkill(agentDir);
  if (!skillContent) {
    return { error: `SKILL.md not found for agent: ${agentId}` };
  }

  // Generate agent file
  const agentContent = generateAgentFile(config, skillContent);

  // Write output
  const outputPath = path.join(OUTPUT_DIR, `${agentId}.md`);
  fs.writeFileSync(outputPath, agentContent, 'utf-8');

  return {
    success: true,
    agentId,
    name: config.name,
    outputPath,
    toolCount: mapMcpServersToTools(config.mcp_servers).length,
  };
}

/**
 * Get list of all agent directories
 */
function getAllAgentIds() {
  if (!fs.existsSync(AGENTS_DIR)) {
    return [];
  }

  return fs.readdirSync(AGENTS_DIR)
    .filter(name => {
      const fullPath = path.join(AGENTS_DIR, name);
      return fs.statSync(fullPath).isDirectory() && !name.startsWith('_');
    });
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2);
  let targetAgent = null;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--agent' && args[i + 1]) {
      targetAgent = args[i + 1];
      i++;
    }
  }

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Get agents to process
  const agentIds = targetAgent ? [targetAgent] : getAllAgentIds();

  if (agentIds.length === 0) {
    console.log('No agents found to process.');
    process.exit(0);
  }

  console.log(`\nAgent Architect -> Claude Code Agent Generation`);
  console.log('='.repeat(50));
  console.log(`Processing ${agentIds.length} agent(s)...\n`);

  const results = {
    success: [],
    skipped: [],
    errors: [],
  };

  for (const agentId of agentIds) {
    const result = processAgent(agentId);

    if (result.success) {
      results.success.push(result);
      console.log(`  [OK] ${result.name} (${result.agentId})`);
      console.log(`       -> .claude/agents/${result.agentId}.md`);
    } else if (result.skipped) {
      results.skipped.push({ agentId, ...result });
    } else {
      results.errors.push({ agentId, ...result });
      console.log(`  [ERROR] ${agentId}: ${result.error}`);
    }
  }

  // Summary
  console.log('\n' + '='.repeat(50));
  console.log(`Summary:`);
  console.log(`  Generated: ${results.success.length}`);
  if (results.skipped.length > 0) {
    console.log(`  Skipped: ${results.skipped.length}`);
  }
  if (results.errors.length > 0) {
    console.log(`  Errors: ${results.errors.length}`);
  }
  console.log('\nGenerated agents are available at: .claude/agents/');
  console.log('Use Claude Code /agents to see them.\n');

  // Exit with error code if there were errors
  if (results.errors.length > 0) {
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

// Export for testing
module.exports = {
  processAgent,
  getAllAgentIds,
  mapMcpServersToTools,
  generateAgentFile,
};
